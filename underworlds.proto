syntax = "proto3";

package underworlds;

service Underworlds {

    // GENERAL

    // Establish the connection to the server, setting a human-friendly name for
    // the client.
    // The server returns a unique client ID that must be used in every subsequent
    // request to the server.
    rpc helo(Welcome) returns (Client) {}

    // Inform the server that the client is disconnecting.
    // Before completing this call, the client must keep its invalidation
    // server open and listening.
    // After completing this call, the server should not attempt to connect to
    // the client's invalidation server.
    rpc byebye(Client) returns (Empty) {}

    // Returns the uptime of the server, in seconds
    rpc uptime(Client) returns (Time) {}

    // Returns the current topology of underworlds: the list of worlds and the
    // list of clients + their interactions with the worlds
    rpc topology(Client) returns (Topology) {}

    // Hard reset of Underworlds: all the worlds are deleted.
    // The existing mesh database is kept, however.
    // This does not impact the list of known clients (ie, clients do not have to
    // call 'helo' again).
    rpc reset(Client) returns (Empty) {}

    // OBJECTS

    // Returns the number of objects in a given world.
    // Accepts a context (client ID and world) and returns the number of existing objects.
    rpc getObjectsLen(Context) returns (Size) {}

    // Returns the list of object IDs present in the given world
    rpc getObjectsIds(Context) returns (IdsInContext) {}

    // Returns the root node ID of the given world
    rpc getRootNode(Context) returns (Object) {}

    // Returns an object from its ID in the given world.
    // Note that only the node ID is used (and thus, required).
    rpc getObject(IdInContext) returns (Object) {}

    // Updates (and broadcasts to all client) objects in a given world
    rpc updateObjects(ObjectsInContext) returns (Empty) {}

    // Deletes (and broadcasts to all client) objects in a given world
    rpc deleteObjects(IdsInContext) returns (Empty) {}

    // MESHES

    // Returns whether the given mesh is already available on the server.
    // Note that only the mesh ID is used.
    rpc hasMesh(MeshInContext) returns (Bool) {}

    // Returns a 3D mesh.
    // Note that only the ID of the input mesh is used.
    rpc getMesh(MeshInContext) returns (Mesh) {}

    // Sends a 3D mesh to the server.
    rpc pushMesh(MeshInContext) returns (Empty) {}
}

service UnderworldsInvalidation {

    // Sends (to the client's invalidation server) 'invalidated'
    // nodes/situations that need to be updated.  Invalidated nodes/situations
    // can be new nodes/situations, nodes/situations that have changed, or
    // nodes/situations that have been removed (see Invalidation.type).
    rpc emitInvalidation(Invalidation) returns (Empty) {}

}
/////////////////////////////////////////////
// GENERIC MESSAGES

message Empty {}

message Bool {
    bool value = 1;
}

message Time {
    // Time (in second). Can represent an absolute time (seconds elapsed since
    // the begining of epoch) or a duration.
    double time = 1;
}

message Welcome {
    string name = 1;
    string host = 2;
    int32 invalidation_server_port = 3;
}


message Size {
    int32 size = 1;
}

// A 3D point with floating point precision
message Pointf {
    float x = 1;
    float y = 2;
    float z = 3;
}

// A 3D point with integral coordinates
message Point {
    sint32 x = 1;
    sint32 y = 2;
    sint32 z = 3;
}

// A RGBA color, each component is in [0,1]
message Color {
    float r = 1;
    float g = 2;
    float b = 3;
    float a = 4;
}

/////////////////////////////////////////////
// CLIENT-RELATED MESSAGE

message Client {
    string id = 1;
    string name = 2;
    repeated ClientInteraction links = 3;
}

message ClientInteraction {

    enum InteractionType {
        READER = 0;
        PROVIDER = 1;
        MONITOR = 2;
        FILTER = 3;
    }

    string world = 1;
    InteractionType type = 2;
    Time last_activity = 3;
}

message Context {
    string client = 1;
    string world = 2;
}

message Invalidation {

    enum Target {
        SCENE = 0;
        TIMELINE = 1;
    }

    Target target = 1;

    enum InvalidationType {
        NEW = 0;
        UPDATE = 1;
        DELETE = 2;
    }

    InvalidationType type = 2;

    string world = 3;

    // the ID of the nodes/situations which are being invalidated
    repeated string ids = 4;
}

/////////////////////////////////////////////
// TOPOLOGY

// Encodes the current topology of Underworlds
message Topology {
    repeated string worlds = 1;
    repeated Client clients = 2;
}

/////////////////////////////////////////////
// OBJECT-RELATED MESSAGES

message Object {

    enum ObjectType {
        UNDEFINED = 0;
        EVENT = 1;
        SITUATION = 2;
        // Entities are abstract nodes. They can represent non-physical objects
        // (like a reference frame) or groups of other objects.
        ENTITY = 3; 
        // a physical object, with an associated 3D mesh
        MESH = 4;
        CAMERA = 5;
    }

    // an unique ID
    string id = 1;

    // a human-friendly name
    string name = 2;

    // the type of object
    ObjectType type = 3;

    // date/time of the last object's update (in sec since the epoch)
    double last_update = 4;

    // list of properties attached to this node. See doc/properties-registry.rst for
    // permitted values.
    // The keys of the mapping are always alphanumeric strings (starting with a
    // letter or an underscore).
    // The values can have various type (see registry). They are encoded in the
    // protobuf message as json strings, but we encourage client
    // implementations to expose the deserialized json values.
    map<string, string> properties = 5;
}

message IdInContext {
    Context context = 1;
    string id = 2;
}

message IdsInContext {
    Context context = 1;
    repeated string ids = 2;
}

message ObjectsInContext {
    Context context = 1;
    repeated Object objects = 2;
}


/////////////////////////////////////////////
// MESH-RELATED MESSAGES

message Mesh {

    // The mesh ID. Typically computed by hashing the mesh object so that identical
    // meshes correspond to the same ID, thus allowing data re-use
    string id = 1;
    repeated Pointf vertices = 2;
    // faces must be triangles and are encoded as a tuple of 3 indices in the
    // vertices array.
    repeated Point faces = 3;
    repeated Pointf normals = 4;
    repeated uint32 colors = 5;

    Color diffuse = 6;
}

message MeshInContext {
    Client client = 1;
    Mesh mesh = 2;
}

